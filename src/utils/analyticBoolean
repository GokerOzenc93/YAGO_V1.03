import * as THREE from 'three';
import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';

// Eksenlere hizalÄ± bir sÄ±nÄ±rlayÄ±cÄ± kutuyu temsil eder (Axis-Aligned Bounding Box)
type AABB = { min: THREE.Vector3; max: THREE.Vector3 };

/**
 * Bir ÅŸeklin dÃ¼nya koordinatlarÄ±ndaki AABB'sini alÄ±r.
 * NOT: Bu basitleÅŸtirilmiÅŸ analitik yaklaÅŸÄ±m, dÃ¶nme (rotation) olmayan ÅŸekiller iÃ§in en iyi sonucu verir.
 * Pozisyon ve Ã¶lÃ§ek uygulanÄ±r ancak rotasyon ÅŸimdilik gÃ¶z ardÄ± edilir.
 * @param shape Shape nesnesi
 * @returns {AABB} Åeklin AABB'si
 */
function getAABBFromShape(shape): AABB {
    const geometry = shape.geometry;
    geometry.computeBoundingBox();
    const bbox = geometry.boundingBox.clone();

    const pos = new THREE.Vector3(...(shape.position || [0, 0, 0]));
    const scale = new THREE.Vector3(...(shape.scale || [1, 1, 1]));

    bbox.min.multiply(scale).add(pos);
    bbox.max.multiply(scale).add(pos);

    return bbox;
}

/**
 * boxB'yi boxA'dan Ã§Ä±karÄ±r ve kalan hacmi temsil eden daha kÃ¼Ã§Ã¼k kutulardan oluÅŸan bir set dÃ¶ndÃ¼rÃ¼r.
 * Bu, A'yÄ± ve kesiÅŸim alanÄ±nÄ± daha kÃ¼Ã§Ã¼k parÃ§alara bÃ¶lerek ve yalnÄ±zca A'da olup B'de olmayan parÃ§alarÄ± tutarak Ã§alÄ±ÅŸÄ±r.
 * @param {AABB} boxA - Ä°Ã§inden Ã§Ä±karma yapÄ±lacak kutu.
 * @param {AABB} boxB - Ã‡Ä±karÄ±lacak kutu.
 * @returns {THREE.BufferGeometry[]} Sonucu temsil eden geometri parÃ§alarÄ± dizisi.
 */
function subtractAABBs(boxA: AABB, boxB: AABB): THREE.BufferGeometry[] {
    // A ve B'nin kesiÅŸim kutusunu hesapla
    const intersection = {
        min: new THREE.Vector3(Math.max(boxA.min.x, boxB.min.x), Math.max(boxA.min.y, boxB.min.y), Math.max(boxA.min.z, boxB.min.z)),
        max: new THREE.Vector3(Math.min(boxA.max.x, boxB.max.x), Math.min(boxA.max.y, boxB.max.y), Math.min(boxA.max.z, boxB.max.z)),
    };

    // EÄŸer kesiÅŸim yoksa, sonuÃ§ sadece boxA'dÄ±r.
    if (intersection.min.x >= intersection.max.x || intersection.min.y >= intersection.max.y || intersection.min.z >= intersection.max.z) {
        const size = new THREE.Vector3().subVectors(boxA.max, boxA.min);
        const center = new THREE.Vector3().addVectors(boxA.max, boxA.min).multiplyScalar(0.5);
        const geom = new THREE.BoxGeometry(size.x, size.y, size.z);
        geom.translate(center.x, center.y, center.z);
        return [geom];
    }

    const resultFragments: THREE.BufferGeometry[] = [];

    // boxA'yÄ± kesiÅŸim kutusunun sÄ±nÄ±rlarÄ±na gÃ¶re 27 parÃ§aya bÃ¶l.
    // Her eksendeki kesim noktalarÄ±nÄ± bul (baÅŸlangÄ±Ã§, bitiÅŸ, kesiÅŸim baÅŸlangÄ±cÄ±, kesiÅŸim bitiÅŸi).
    const cutsX = [boxA.min.x, boxA.max.x, intersection.min.x, intersection.max.x].sort((a, b) => a - b).filter((v, i, a) => i === 0 || v > a[i - 1]);
    const cutsY = [boxA.min.y, boxA.max.y, intersection.min.y, intersection.max.y].sort((a, b) => a - b).filter((v, i, a) => i === 0 || v > a[i - 1]);
    const cutsZ = [boxA.min.z, boxA.max.z, intersection.min.z, intersection.max.z].sort((a, b) => a - b).filter((v, i, a) => i === 0 || v > a[i - 1]);

    // TÃ¼m kÃ¼Ã§Ã¼k parÃ§alarÄ± (fragmanlarÄ±) dolaÅŸ.
    for (let i = 0; i < cutsX.length - 1; i++) {
        for (let j = 0; j < cutsY.length - 1; j++) {
            for (let k = 0; k < cutsZ.length - 1; k++) {
                const min = new THREE.Vector3(cutsX[i], cutsY[j], cutsZ[k]);
                const max = new THREE.Vector3(cutsX[i+1], cutsY[j+1], cutsZ[k+1]);
                const center = new THREE.Vector3().addVectors(min, max).multiplyScalar(0.5);

                // Bu fragman boxA'nÄ±n iÃ§inde mi?
                if (center.x > boxA.min.x && center.x < boxA.max.x &&
                    center.y > boxA.min.y && center.y < boxA.max.y &&
                    center.z > boxA.min.z && center.z < boxA.max.z) {

                    // VE bu fragman boxB'nin (Ã§Ä±karÄ±lacak alan) dÄ±ÅŸÄ±nda mÄ±?
                    if (!(center.x > boxB.min.x && center.x < boxB.max.x &&
                          center.y > boxB.min.y && center.y < boxB.max.y &&
                          center.z > boxB.min.z && center.z < boxB.max.z)) {
                        
                        const size = new THREE.Vector3().subVectors(max, min);
                        // Ã‡ok kÃ¼Ã§Ã¼k fragmanlarÄ± atla
                        if (size.x > 1e-6 && size.y > 1e-6 && size.z > 1e-6) {
                            const geom = new THREE.BoxGeometry(size.x, size.y, size.z);
                            geom.translate(center.x, center.y, center.z);
                            resultFragments.push(geom);
                        }
                    }
                }
            }
        }
    }

    return resultFragments;
}

/**
 * Ä°ki ÅŸekil arasÄ±nda analitik Ã§Ä±karma iÅŸlemi gerÃ§ekleÅŸtirir.
 * Sonucu temiz ve birleÅŸik bir BufferGeometry olarak dÃ¶ndÃ¼rÃ¼r.
 * @param targetShape - Ä°Ã§inden Ã§Ä±karma yapÄ±lacak ÅŸekil.
 * @param subtractShape - Ã‡Ä±karÄ±lacak ÅŸekil.
 * @returns {THREE.BufferGeometry | null} SonuÃ§ geometri veya baÅŸarÄ±sÄ±z olursa null.
 */
export function performAnalyticSubtract(targetShape, subtractShape): THREE.BufferGeometry | null {
    console.log("ğŸ¯ Analitik Ã‡Ä±karma Ä°ÅŸlemi BaÅŸlatÄ±ldÄ± (AABB YaklaÅŸÄ±mÄ±)");
    
    // Åekillerin dÃ¼nya koordinatlarÄ±ndaki AABB'lerini al.
    const targetAABB = getAABBFromShape(targetShape);
    const subtractAABB = getAABBFromShape(subtractShape);

    // Ã‡Ä±karma iÅŸlemi sonucunda oluÅŸacak geometri parÃ§alarÄ±nÄ± hesapla.
    const fragments = subtractAABBs(targetAABB, subtractAABB);

    if (fragments.length === 0) {
        console.log("Analitik Ã§Ä±karma sonucu boÅŸ.");
        return null;
    }

    // TÃ¼m parÃ§alarÄ± tek bir geometri altÄ±nda birleÅŸtir.
    if (fragments.length === 1) {
        return fragments[0];
    }

    const mergedGeometry = BufferGeometryUtils.mergeGeometries(fragments, false);
    
    // BelleÄŸi boÅŸaltmak iÃ§in fragman geometrilerini temizle.
    fragments.forEach(geom => geom.dispose());

    return mergedGeometry;
}
