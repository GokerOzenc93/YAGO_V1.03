import * as THREE from 'three';
import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';

// Eksenlere hizalı bir sınırlayıcı kutuyu temsil eder (Axis-Aligned Bounding Box)
type AABB = { min: THREE.Vector3; max: THREE.Vector3 };

/**
 * Bir şeklin dünya koordinatlarındaki AABB'sini alır.
 * NOT: Bu basitleştirilmiş analitik yaklaşım, dönme (rotation) olmayan şekiller için en iyi sonucu verir.
 * Pozisyon ve ölçek uygulanır ancak rotasyon şimdilik göz ardı edilir.
 * @param shape Shape nesnesi
 * @returns {AABB} Şeklin AABB'si
 */
function getAABBFromShape(shape): AABB {
    const geometry = shape.geometry;
    geometry.computeBoundingBox();
    const bbox = geometry.boundingBox.clone();

    const pos = new THREE.Vector3(...(shape.position || [0, 0, 0]));
    const scale = new THREE.Vector3(...(shape.scale || [1, 1, 1]));

    bbox.min.multiply(scale).add(pos);
    bbox.max.multiply(scale).add(pos);

    return bbox;
}

/**
 * boxB'yi boxA'dan çıkarır ve kalan hacmi temsil eden daha küçük kutulardan oluşan bir set döndürür.
 * Bu, A'yı ve kesişim alanını daha küçük parçalara bölerek ve yalnızca A'da olup B'de olmayan parçaları tutarak çalışır.
 * @param {AABB} boxA - İçinden çıkarma yapılacak kutu.
 * @param {AABB} boxB - Çıkarılacak kutu.
 * @returns {THREE.BufferGeometry[]} Sonucu temsil eden geometri parçaları dizisi.
 */
function subtractAABBs(boxA: AABB, boxB: AABB): THREE.BufferGeometry[] {
    // A ve B'nin kesişim kutusunu hesapla
    const intersection = {
        min: new THREE.Vector3(Math.max(boxA.min.x, boxB.min.x), Math.max(boxA.min.y, boxB.min.y), Math.max(boxA.min.z, boxB.min.z)),
        max: new THREE.Vector3(Math.min(boxA.max.x, boxB.max.x), Math.min(boxA.max.y, boxB.max.y), Math.min(boxA.max.z, boxB.max.z)),
    };

    // Eğer kesişim yoksa, sonuç sadece boxA'dır.
    if (intersection.min.x >= intersection.max.x || intersection.min.y >= intersection.max.y || intersection.min.z >= intersection.max.z) {
        const size = new THREE.Vector3().subVectors(boxA.max, boxA.min);
        const center = new THREE.Vector3().addVectors(boxA.max, boxA.min).multiplyScalar(0.5);
        const geom = new THREE.BoxGeometry(size.x, size.y, size.z);
        geom.translate(center.x, center.y, center.z);
        return [geom];
    }

    const resultFragments: THREE.BufferGeometry[] = [];

    // boxA'yı kesişim kutusunun sınırlarına göre 27 parçaya böl.
    // Her eksendeki kesim noktalarını bul (başlangıç, bitiş, kesişim başlangıcı, kesişim bitişi).
    const cutsX = [boxA.min.x, boxA.max.x, intersection.min.x, intersection.max.x].sort((a, b) => a - b).filter((v, i, a) => i === 0 || v > a[i - 1]);
    const cutsY = [boxA.min.y, boxA.max.y, intersection.min.y, intersection.max.y].sort((a, b) => a - b).filter((v, i, a) => i === 0 || v > a[i - 1]);
    const cutsZ = [boxA.min.z, boxA.max.z, intersection.min.z, intersection.max.z].sort((a, b) => a - b).filter((v, i, a) => i === 0 || v > a[i - 1]);

    // Tüm küçük parçaları (fragmanları) dolaş.
    for (let i = 0; i < cutsX.length - 1; i++) {
        for (let j = 0; j < cutsY.length - 1; j++) {
            for (let k = 0; k < cutsZ.length - 1; k++) {
                const min = new THREE.Vector3(cutsX[i], cutsY[j], cutsZ[k]);
                const max = new THREE.Vector3(cutsX[i+1], cutsY[j+1], cutsZ[k+1]);
                const center = new THREE.Vector3().addVectors(min, max).multiplyScalar(0.5);

                // Bu fragman boxA'nın içinde mi?
                if (center.x > boxA.min.x && center.x < boxA.max.x &&
                    center.y > boxA.min.y && center.y < boxA.max.y &&
                    center.z > boxA.min.z && center.z < boxA.max.z) {

                    // VE bu fragman boxB'nin (çıkarılacak alan) dışında mı?
                    if (!(center.x > boxB.min.x && center.x < boxB.max.x &&
                          center.y > boxB.min.y && center.y < boxB.max.y &&
                          center.z > boxB.min.z && center.z < boxB.max.z)) {
                        
                        const size = new THREE.Vector3().subVectors(max, min);
                        // Çok küçük fragmanları atla
                        if (size.x > 1e-6 && size.y > 1e-6 && size.z > 1e-6) {
                            const geom = new THREE.BoxGeometry(size.x, size.y, size.z);
                            geom.translate(center.x, center.y, center.z);
                            resultFragments.push(geom);
                        }
                    }
                }
            }
        }
    }

    return resultFragments;
}

/**
 * İki şekil arasında analitik çıkarma işlemi gerçekleştirir.
 * Sonucu temiz ve birleşik bir BufferGeometry olarak döndürür.
 * @param targetShape - İçinden çıkarma yapılacak şekil.
 * @param subtractShape - Çıkarılacak şekil.
 * @returns {THREE.BufferGeometry | null} Sonuç geometri veya başarısız olursa null.
 */
export function performAnalyticSubtract(targetShape, subtractShape): THREE.BufferGeometry | null {
    console.log("🎯 Analitik Çıkarma İşlemi Başlatıldı (AABB Yaklaşımı)");
    
    // Şekillerin dünya koordinatlarındaki AABB'lerini al.
    const targetAABB = getAABBFromShape(targetShape);
    const subtractAABB = getAABBFromShape(subtractShape);

    // Çıkarma işlemi sonucunda oluşacak geometri parçalarını hesapla.
    const fragments = subtractAABBs(targetAABB, subtractAABB);

    if (fragments.length === 0) {
        console.log("Analitik çıkarma sonucu boş.");
        return null;
    }

    // Tüm parçaları tek bir geometri altında birleştir.
    if (fragments.length === 1) {
        return fragments[0];
    }

    const mergedGeometry = BufferGeometryUtils.mergeGeometries(fragments, false);
    
    // Belleği boşaltmak için fragman geometrilerini temizle.
    fragments.forEach(geom => geom.dispose());

    return mergedGeometry;
}
